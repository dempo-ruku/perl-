
# ファイル指定
    # print "Hello world!!\n";

# 基礎知識
    # $xx = 5;
    # $yy = 2;
    # $zz = $xx + $yy;
    # print "答は $zz です。\n";

# # 数値表現
#     12345          # 整数
#     12_345         # 整数(アンダーバーは無視されます)
#     123.45         # 小数
#     1.23E45        # 指数
#     0x12345        # 16進数
#     012345         # 8進数

# # 文字列
#     # 文字列は '' or "" で囲む
#         "abc"
#         'abc'
#     # どちらかを中で使うことも可能
#         "abc'def'ghi"
#         'abc"def"ghi'
#     # "" の中に "" を使う場合は \ を使う
#         "ダブルクォーテーション(\")を使う"
      # '' の中では文字列として認識されてしまうので注意
        # $xx = 7;
        # print "答は$xxです\n";
        # print '答は$xxです\n';
# エスケープシーケンス(\)
    # \t        # タブ文字（\x09）
    # \n        # 改行（\x0a）
    # \r        # リターン（\x0d）
    # \f        # フォームフィード（\x0c）
    # \b        # バックスペース（\x08）
    # \a        # アラーム（\x07）
    # \e        # エスケープ文字（\x1b）
    # \033      # 文字コード(8進数)
    # \x1b      # 文字コード(16進数)
    # \c[       # コントロール文字
    # \l        # 次の１文字を小文字にする
    # \u        # 次の１文字を大文字にする
    # \L        # \Eまでの文字列を小文字にする
    # \U        # \Eまでの文字列を大文字にする
    # \E        # \Lや\Uを終了させます
    # \" など   # ダブルクォーテーション( " )自身を表わします。
# スカラー変数($XXX)
    # ダラー( $ )で始まる変数はスカラー変数。数値や文字列を ひとつ だけ代入することが可能（同じ変数名なら一番最後に定義したのが適用される）
        # $xx = 5;
        # $xx = "abc";
        # print "$xx\n";
# 配列
    # $変数名[添え字]という形式で配列を表現することが可能
        # $xx[0] = 5;
        # $xx[1] = "abc";
        # print "$xx[0]\n";
    # 次の形式のようにアットマーク( @ )を用いて配列全体や配列の範囲を表現します。
        # @xx = ( "aa", "bb" );       # 配列xxにaa,bbを代入します。
        # $xx[2] = 'cc';              # 2番目の要素にccを代入します。
        # @xx[3..4] = ( "dd", "ee" ); # 3～4番目の要素にdd,eeを代入します。
        # print "@xx\n";
        # print "$xx[0]\n";
        # print "@xx[0..2]\n";
    # $#変数名 は、@変数名 の配列の最後の添え字（個数から１をひいたもの）を表わします。
    #     @xx = ( "aa", "bb", "cc", "dd" );
    #     print "$#xx\n";
    # # 配列の一括代入も可能
    #     ( $year, $mon, $day ) = ( 1997, 2, 3 );
    #     print "$year, $mon, $day\n";
    # # 空配列
    #     # @xx = ();
    # # 配列を操作するための関数
    #     $x = shift(@xx);      # 最初の要素を取り除き、これを返す
    #     $x = pop(@xx);        # 最後の要素を取り除き、これを返す
    #     push(@xx1, $xx);      # 最後に要素を追加する
    #     push(@xx1, @xx2);     # @xx1 の後ろに @xx2 の要素を追加する
    #     splice(@xx, 3, 2);    # $xx[3..4](2個)を取り除き、これを返す
    #     reverse(@xx);         # @xxの要素を逆順にしたものを返す
    #     sort(@xx);            # @xxの要素をソートした結果を返す
    #     @x = split(/,/, $s);  # 文字列$sを","で分割してその配列を返す
    #     print "@x\n";
# 連想配列
    # $変数名{文字列}という形式が連想配列
        # $xx{"Tanaka"} = "man";
        # $xx{"Suzuki"} = "female";
        # %xx = ( "tanaka", "man", "suzuki", "female" );
        # print "$xx{'tanaka'}\n";
        # print $xx{"suzuki"};
    # すべての連想配列要素について処理
        # while (($name, $value) = each(%xx)) {
        #     print "$name = $value\n";
        # }
# 変数名に使える文字
    # $my-name       # × ハイフン( - )は使用できない
    # $32xx          # × 数値で始まってはならない
# 数値と文字列
    # !!数字と文字列の扱いが曖昧！！！！気をつけるように
        # $xx = 12345;
        # print $xx + 5;
# 環境変数($ENV{'XXX'})
    # perlでは%ENVという特別な連想配列変数を用いて環境変数の値を読み取ったり設定したりすることが可能
        # print $ENV{'PATH'};        # 環境変数PATHの値を表示する
        # $ENV{'TZ'} = "JST-9";      # 環境変数TZに値を設定する
# コマンド引数($ARGV)？？？
    # @ARGV          # 引数の配列
    # $#ARGV         # 配列の個数－1
    # $ARGV[0]       # 最初の引数
    # $ARGV[$#ARGV]  # 最後の引数
# バイナリデータ
    # pack と unpack はバイナリデータに対して、文字表現、数値表現の変換を行う
        # $xx = "ABC";                      # 文字列としての代入
        # @yy = unpack("C*", $xx);          # 数値の配列に変換！？
        # $zz = pack("C*", @yy);            # 数値の配列を文字列に変換
        # print "[$xx] [@yy] [$zz]\n";
# 演算子
    # 算術演算子（特に変わらず）
        # $xx = 5 + 2;        # 足し算
        # $xx = 5 - 2;        # 引き算
        # $xx = 5 * 2;        # 掛け算
        # $xx = 5 / 2;        # 割り算
        # $xx = 5 % 2;        # 5を2で割った余り(=1)
        # $xx = 5 ** 2;       # 5の2乗(=25)
        # $xx++;              # $xxの値が1加算されます
        # $xx--;              # $xxの値が1減算されます
        # $xx **= 2;          # $xx = $xx ** 2; と同様
    # ビット演算子
        # $xx | $yy           # $xxと$yyのOR
        # $xx & $yy           # $xxと$yyのAND
        # ~$xx                # $xxのビットをすべて反転させたもの
        # $xx << 2            # $xxを2ビット左シフト
        # $xx >> 2            # $xxを2ビット右シフト(上位ビットには符号ビットを埋める)
    # 数値比較演算子
        # if ($xx == $yy)            # $xxと$yyが等しければ
        # if ($xx != $yy)            # $xxと$yyが異なっていれば
        # if ($xx < $yy)             # $xxが$yyより小さければ
        # if ($xx > $yy)             # $xxが$yyより大きければ
        # if ($xx <= $yy)            # $xxが$yyより等しいか小さければ
        # if ($xx >= $yy)            # $xxが$yyより等しいか大きければ
        # if (($xx==2) && ($yy==3))  # $xxが2、かつ、$yyが3であれば
        # if (($xx==2) || ($yy==3))  # $xxが2、もしくは、$yyが3であれば
        # if ($xx <=> $yy)           # 比較結果を -1, 0, 1 のいずれかで返す
    # 文字列比較演算子
        # if ($xx eq $yy)            # $xxと$yyが等しければ
        # if ($xx ne $yy)            # $xxと$yyが異なっていれば
        # if ($xx lt $yy)            # $xxが$yyより小さければ
        # if ($xx gt $yy)            # $xxが$yyより大きければ
        # if ($xx le $yy)            # $xxが$yyより等しいか小さければ
        # if ($xx ge $yy)            # $xxが$yyより等しいか大きければ
        # if ($xx =~ /ABC/)          # $xxがABCという文字を含んでいれば
        # if ($xx !~ /ABC/)          # $xxがABCという文字を含んでいなければ
        # if ($xx cmp $yy)           # 比較し、-1, 0, 1 のいずれかで返す
    # 条件演算子
        # A ? B : C は、Aが真であればBを、偽であればCを値とします。
        # $xx = ($yy < 5) ? "small" :  "big";
    # マッチング
        # 変数$xxと正規表現にマッチするか否かを調べれる。
            # if ($xx =~ /[0-9]+/)        # 正規表現にマッチすれば
            # if ($xx !~ /[0-9]+/)        # 正規表現にマッチしなければ
        # 置換文字列の中に括弧を書くと、その括弧に対応した文字列を $1, $2, ... で参照することができます。
            # $xx = "12:34:56";
            # if ($xx =~ /([0-9][0-9]):([0-9][0-9]):([0-9][0-9])/) {
            #     print $1 * 3600 + $2 * 60 + $3;
            # }
    # 文字列連結
        # $xx = $yy . $zz;    # 文字列 $yy と 文字列 $zz を連結します
        # $xx .= $yy;         # $xx = $xx . $yy と同様です。
    # 繰り返し演算子
        # print '-' x 80;     # '-'を80個表示します。
        # $xx x= 80;          # $xx を80回繰り返したものを$xxに代入します。
        # @ones = (1) x 80;   # 80個の(1, 1, 1, 1, ......, 1)と同様です。
    # 範囲演算子
        # @xx = (0 .. 5);     # @xx = (0, 1, 2, 3, 4, 5);と同様。
        # for (0 .. 5)        # for ($_ = 0; $_ <= 5; $_++) と同様
# 制御構文
    # if elsif else文
        # $xx = 7;
        # if ($xx > 5) {
        #     print "5より大きい\n";
        # } elsif ($xx == 5) {
        #     print "5ちょうど\n";
        # } else {
        #     print "5より小さい\n";
        # }
    # unless文
        # unless(...)はif(...)と逆の意味を持ちます。
        # unless ($xx > 5) {
        #     print "5より大きくない\n";
        # };
    # while文
        # while(...)は、(...)が真のあいだ{...}を繰り返します。
        # $xx = 1;
        # while ($xx < 10) {
        #     print "xx = $xx\n";
        #     $xx++;
        # }
    # until文
        # until(...)は、(...)が真になるまで{...}を繰り返します。
        # $xx = 1;
        # until ($xx > 10) {
        #     print "xx = $xx\n";
        #     $xx++;
        # }
    # do文
        # do{...}を用いて、if(...), unless(...), while(...), until(...)の構文順序を変更することができます。
            # do { print "xx = $xx\n"; } if ($xx == 5);
            # do { print "xx = $xx\n"; } unless ($xx == 5);
            # do { print "xx = $xx\n"; $xx++; } while ($xx < 5);
            # do { print "xx = $xx\n"; $xx++; } until ($xx > 5);
        # do {...}の中身が単文の場合は、do { ; }を省略することができます。
            # print "xx = $xx\n" if ($xx == 5);
            # print "xx = $xx\n" unless ($xx == 5);
            # print "xx = $xx\n" while ($xx++ < 5);
            # print "xx = $xx\n" until ($xx++ > 5);
    # for文
        # for(...)は指定回数処理を実行する際に用います。次の例は最初に$xxに1を代入して、$xxが10以下であるあいだ、$xxを1ずつ加算しながら、printを実行することを意味します。
            # for ($xx = 1; $xx <= 10; $xx++) {
            #     print "xx = $xx\n";
            # }
        # 上と同じ内容
            # @xx = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
            # for (@xx) {
            #     print "xx = $_\n";
            # }
        # 上と同じ内容
            # for (1..10) {
            #     print "xx = $_\n";
            # }
    # foreach文
        # @xx = ( 11, 22, 33, 44 );
        # foreach $i (@xx) {
        #     print "i = $i\n";
        # }
    # continue文
        # for ($xx = 1; $xx < 10; $xx++) {
        #     print "$xx\n";
        # }
        # # 上と同じ
        # $xx = 1;
        # while ($xx < 10) {
        #     print "$xx\n";
        # } continue {
        #     $xx++;
        # }